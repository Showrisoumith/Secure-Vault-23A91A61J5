**Secure Vault & Authorization Manager ** This project implements a secure, production-ready treasury system that separates fund management from access control. By using an external Authorization Manager, we ensure that the vault's assets are only accessible via cryptographically verified permissions.

ğŸš€ Quick Start You don't need to configure a local environment to see this in action. The entire stackâ€”including a local blockchain and the deployment scriptâ€”is containerized.

Bash

docker-compose up --build Once the containers are up, the deployer service will automatically output the contract addresses for both the AuthorizationManager and the SecureVault.

ğŸ— System Architecture Weâ€™ve adopted a "Separation of Concerns" model to minimize the attack surface of the vault.

SecureVault: This is the heavy lifter that holds the ETH. It is intentionally "dumb"â€”it doesn't know who is allowed to withdraw; it simply asks the Manager if a provided signature is valid.

AuthorizationManager: This acts as the gatekeeper. It handles the complex logic of ECDSA verification and maintains the state of used authorizations.

ğŸ” Security Design Off-Chain Authorization To save on gas and allow for flexible permissions, we use EIP-191 compliant ECDSA signatures.

Contextual Binding: We don't just sign a "yes" or "no." The signature includes the Vaultâ€™s address, the receiver, the specific amount, a unique nonce, and the Chain ID. This ensures a signature meant for a testnet vault can't be used to drain a mainnet vault.

Cryptographic Verification: The system uses ecrecover to prove that the signature was generated by the trusted off-chain authority.

Replay Protection A common vulnerability in signature-based systems is "replaying" a valid message. We stop this by:

Assigning every authorization a unique nonce.

Recording that nonce in the contract's storage the moment it's used.

Instantly reverting any transaction that tries to reuse a nonce, protecting the vault from double-spending.

ğŸ›  Manual Testing If you prefer to run the suite directly on your host machine:

Install dependencies: npm install

Compile: npx hardhat compile

Run Security Suite: npx hardhat test tests/system.spec.js

ğŸ“ Key Considerations Key Management: This system assumes the trusted signer's private key is stored in a secure hardware module (HSM) or a managed service like AWS KMS.

Design Trade-offs: We chose a single-signer model for simplicity and speed, though the architecture allows for a multi-sig upgrade in the future.

Efficiency: By requiring users to provide the signature, the vault offloads the "permission check" computational cost to the requester, keeping the protocol gas-efficient.
